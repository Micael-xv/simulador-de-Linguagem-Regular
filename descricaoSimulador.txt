import tkinter as tk
from tkinter import messagebox, scrolledtext, font

Essas linhas importam o módulo tkinter e alguns de seus componentes. tkinter é uma biblioteca padrão do Python usada para criar interfaces gráficas.

Classe Automato
  class Automato:
    def __init__(self):
        self.estados = set()
        self.alfabeto = set()
        self.transicoes = {}
        self.estadoInicial = None
        self.estadosDeAceitacao = set()

A classe Automato representa um autômato finito. O método __init__ inicializa os seguintes atributos:

estados: um conjunto que armazena todos os estados do autômato.
alfabeto: um conjunto que armazena todos os símbolos do alfabeto do autômato.
transicoes: um dicionário que armazena as transições do autômato. As chaves são estados de origem e os valores são dicionários onde as chaves são símbolos e os valores são conjuntos de estados de destino.
estadoInicial: armazena o estado inicial do autômato.
estadosDeAceitacao: um conjunto que armazena os estados de aceitação do autômato.

Método adicionar_estado
    def adicionar_estado(self, estado, inicial=False, aceitacao=False):
        self.estados.add(estado)
        if inicial:
            self.estadoInicial = estado
        if aceitacao:
            self.estadosDeAceitacao.add(estado)

Este método adiciona um estado ao autômato. Ele aceita três parâmetros:

estado: o estado a ser adicionado.
inicial: um booleano que indica se o estado é o estado inicial.
aceitacao: um booleano que indica se o estado é um estado de aceitação.

Método adicionar_transicao
    def adicionar_transicao(self, origem, simbolo, destino):
        if origem not in self.transicoes:
            self.transicoes[origem] = {}
        if simbolo not in self.transicoes[origem]:
            self.transicoes[origem][simbolo] = set()
        self.transicoes[origem][simbolo].add(destino)

Este método adiciona uma transição ao autômato. Ele aceita três parâmetros:

origem: o estado de origem da transição.
simbolo: o símbolo que causa a transição.
destino: o estado de destino da transição.

Método validar_cadeia
    def validar_cadeia(self, cadeia):
        estados_atuais = {self.estadoInicial}
        for simbolo in cadeia:
            proximos_estados = set()
            for estado in estados_atuais:
                if estado in self.transicoes and simbolo in self.transicoes[estado]:
                    proximos_estados.update(self.transicoes[estado][simbolo])
            estados_atuais = proximos_estados
        return bool(estados_atuais & self.estadosDeAceitacao)

Este método verifica se uma cadeia de símbolos é aceita pelo autômato. Ele aceita um parâmetro:

cadeia: a cadeia de símbolos a ser validada.
O método funciona da seguinte maneira:

Inicializa estados_atuais com o estado inicial do autômato.
Para cada símbolo na cadeia, atualiza estados_atuais com os estados de destino das transições possíveis a partir dos estados atuais.
No final, verifica se algum dos estados atuais é um estado de aceitação.

Função converter_gramatica_para_automato
def converter_gramatica_para_automato(regras, simbolo_inicial):
    automato = Automato()
    for regra in regras:
        esquerda, direita = regra.split("->")
        esquerda = esquerda.strip()
        automato.adicionar_estado(esquerda, inicial=(esquerda == simbolo_inicial))
        producoes = direita.split("|")
        for producao in producoes:
            producao = producao.strip()
            if producao == "ε":
                automato.adicionar_estado(esquerda, aceitacao=True)
            elif len(producao) == 1:  # Apenas terminal
                automato.adicionar_estado("final", aceitacao=True)
                automato.adicionar_transicao(esquerda, producao, "final")
            else:
                terminal, nao_terminal = producao[0], producao[1:]
                automato.adicionar_estado(nao_terminal)
                automato.adicionar_transicao(esquerda, terminal, nao_terminal)
    return automato
Esta função converte uma gramática em um autômato. Ela aceita dois parâmetros:

regras: uma lista de regras da gramática.
simbolo_inicial: o símbolo inicial da gramática.
A função funciona da seguinte maneira:

Cria uma instância da classe Automato.
Para cada regra na lista de regras, divide a regra em parte esquerda e direita.
Adiciona a parte esquerda como um estado do autômato, marcando-o como inicial se for o símbolo inicial.
Divide a parte direita em produções separadas por |.
Para cada produção, se for ε, adiciona o estado como estado de aceitação. Se for um terminal, adiciona uma transição para um estado final. Se for uma combinação de terminal e não-terminal, adiciona a transição correspondente.

Classe SimuladorGramatica
class SimuladorGramatica:
    def __init__(self, janela):
        self.janela = janela
        self.janela.title("Simulador de Gramática e Autômato")
        self.janela.geometry("800x500")
        self.janela.configure(bg="#f5f5f5")

        fonte_titulo = font.Font(family="Helvetica", size=16, weight="bold")
        fonte_label = font.Font(family="Helvetica", size=12)

        titulo = tk.Label(
            self.janela, text="Simulador de Gramática e Autômato", font=fonte_titulo, bg="#f5f5f5", fg="#333"
        )
        titulo.pack(pady=10)

        self.framePrincipal = tk.Frame(self.janela, bg="#f5f5f5")
        self.framePrincipal.pack(pady=10, padx=10, fill="both", expand=True)

        tk.Label(
            self.framePrincipal, text="Gramática Regular:", font=fonte_label, bg="#f5f5f5"
        ).grid(row=0, column=0, padx=10, sticky="w")
        self.entradaGramatica = scrolledtext.ScrolledText(self.framePrincipal, width=40, height=10)
        self.entradaGramatica.grid(row=1, column=0, padx=10, pady=5)

        tk.Label(
            self.framePrincipal, text="Símbolo Inicial:", font=fonte_label, bg="#f5f5f5"
        ).grid(row=0, column=1, padx=10, sticky="w")
        self.simboloInicial = tk.Entry(self.framePrincipal, width=15)
        self.simboloInicial.grid(row=1, column=1, padx=10, pady=5)

        tk.Label(
            self.framePrincipal, text="Cadeias (separadas por vírgula):", font=fonte_label, bg="#f5f5f5"
        ).grid(row=2, column=0, padx=10, sticky="w")
        self.cadeiasTeste = tk.Entry(self.framePrincipal, width=60)
        self.cadeiasTeste.grid(row=3, column=0, columnspan=2, padx=10, pady=5)

        self.botaoTestar = tk.Button(self.janela, text="Testar", command=self.executar_simulacao, bg="#4CAF50", fg="white", padx=10, pady=5)
        self.botaoTestar.pack(pady=10)

        tk.Label(
            self.framePrincipal, text="Resultados:", font=fonte_label, bg="#f5f5f5"
        ).grid(row=4, column=0, columnspan=2, pady=5)
        self.resultadoSaida = scrolledtext.ScrolledText(self.framePrincipal, width=70, height=10, state="disabled")
        self.resultadoSaida.grid(row=5, column=0, columnspan=2, padx=10, pady=5)
A classe SimuladorGramatica cria a interface gráfica do simulador. O método __init__ inicializa a janela principal e os componentes da interface:

janela: a janela principal do simulador.
fonte_titulo: a fonte usada para o título.
fonte_label: a fonte usada para os rótulos.
titulo: o rótulo do título.
framePrincipal: o frame principal que contém os componentes da interface.
entradaGramatica: um campo de texto para a entrada da gramática.
simboloInicial: um campo de entrada para o símbolo inicial.
cadeiasTeste: um campo de entrada para as cadeias de teste.
botaoTestar: um botão para iniciar a simulação.
resultadoSaida: um campo de texto para exibir os resultados.

Método executar_simulacao
    def executar_simulacao(self):
        texto_gramatica = self.entradaGramatica.get("1.0", tk.END).strip()
        simbolo_inicial = self.simboloInicial.get().strip()
        cadeias_teste = self.cadeiasTeste.get().strip().split(",")

        if not texto_gramatica, not simbolo_inicial, or not cadeias_teste:
            messagebox.showerror("Erro", "Preencha todos os campos.")
            return

        regras = texto_gramatica.splitlines()
        try:
            automato = converter_gramatica_para_automato(regras, simbolo_inicial)
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao processar a gramática: {e}")
            return

        resultados = []
        for cadeia in cadeias_teste:
            cadeia = cadeia.strip()
            if automato.validar_cadeia(cadeia):
                resultados.append(f"'{cadeia}' -> Aceita")
            else:
                resultados.append(f"'{cadeia}' -> Rejeitada")

        self.resultadoSaida.config(state="normal")
        self.resultadoSaida.delete("1.0", tk.END)
        self.resultadoSaida.insert(tk.END, "\n".join(resultados))
        self.resultadoSaida.config(state="disabled")
Este método é chamado quando o botão "Testar" é clicado. Ele executa a simulação da gramática e exibe os resultados:

Obtém o texto da gramática, o símbolo inicial e as cadeias de teste dos campos de entrada.
Verifica se todos os campos foram preenchidos. Se não, exibe uma mensagem de erro.
Divide o texto da gramática em regras.
Tenta converter a gramática em um autômato. Se ocorrer um erro, exibe uma mensagem de erro.
Para cada cadeia de teste, verifica se a cadeia é aceita pelo autômato e armazena o resultado.
Exibe os resultados no campo de texto resultadoSaida.

Execução do Programa
if __name__ == "__main__":
    janela = tk.Tk()
    app = SimuladorGramatica(janela)
    janela.mainloop()

Estas linhas iniciam o programa. Se o script for executado diretamente, cria uma instância da janela principal e uma instância da classe SimuladorGramatica, e inicia o loop principal da interface gráfica.